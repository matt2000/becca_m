function task = task_step(task)

task.action = task.agent.action;

col_step = round ( ...
           task.action(1) * task.MAX_STEP_SIZE / 2 + ...
           task.action(2) * task.MAX_STEP_SIZE / 4 + ...
           task.action(3) * task.MAX_STEP_SIZE / 8 + ...
           task.action(4) * task.MAX_STEP_SIZE / 16 - ...
           task.action(5) * task.MAX_STEP_SIZE / 2 - ...
           task.action(6) * task.MAX_STEP_SIZE / 4 - ...
           task.action(7) * task.MAX_STEP_SIZE / 8 - ...
           task.action(8) * task.MAX_STEP_SIZE / 16 );

col_step = round( col_step * ( 1 + 0.1 * rand(1) - 0.1 * rand(1)));
task.col_pos = task.col_pos + col_step;
 
if task.col_pos > task.col_max task.col_pos = task.col_max; end
if task.col_pos < task.col_min task.col_pos = task.col_min; end

% creates sensory input vector
fov = task.data(:, task.col_pos - floor( task.fov_wid/2): ...
                  task.col_pos + floor( task.fov_wid/2));
task.sensory_input = zeros(task.fov_span ^ 2, 1);

for row = 1:task.fov_span,
    for col = 1:task.fov_span,
        task.sensory_input(row + task.fov_span * (col - 1)) = ... 
            mean( mean( fov( (row - 1) * ...
            task.block_wid + 1: row * task.block_wid, ...
            (col - 1) * task.block_wid + 1: col * task.block_wid )))...
                / 256;
    end
end

task.sensory_input = task.sensory_input(:);
task.sensory_input = vertcat(task.sensory_input, 1 - task.sensory_input);
task.basic_feature_input = zeros(task.basic_feature_length,1);
task.reward = task_calc_reward( task);
