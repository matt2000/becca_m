function task = task_step(task)

task.action = task.agent.action;

col_step = round ( ...
           task.action(1) * task.MAX_STEP_SIZE / 2 + ...
           task.action(2) * task.MAX_STEP_SIZE / 4 + ...
           task.action(3) * task.MAX_STEP_SIZE / 8 + ...
           task.action(4) * task.MAX_STEP_SIZE / 16 - ...
           task.action(5) * task.MAX_STEP_SIZE / 2 - ...
           task.action(6) * task.MAX_STEP_SIZE / 4 - ...
           task.action(7) * task.MAX_STEP_SIZE / 8 - ...
           task.action(8) * task.MAX_STEP_SIZE / 16 );

row_step = round ( ...
           task.action(9) * task.MAX_STEP_SIZE / 2 + ...
           task.action(10) * task.MAX_STEP_SIZE / 4 + ...
           task.action(11) * task.MAX_STEP_SIZE / 8 + ...
           task.action(12) * task.MAX_STEP_SIZE / 16 - ...
           task.action(13) * task.MAX_STEP_SIZE / 2 - ...
           task.action(14) * task.MAX_STEP_SIZE / 4 - ...
           task.action(15) * task.MAX_STEP_SIZE / 8 - ...
           task.action(16) * task.MAX_STEP_SIZE / 16 );

%introduces random noise into the movements with a magnitude 
% NOISE_MAG, typical
NOISE_MAG = 0.05;
col_step = round( col_step * ( 1 + 2 * NOISE_MAG * rand(1) - ...
    2 * NOISE_MAG * rand(1)));
row_step = round( row_step * ( 1 + 2 * NOISE_MAG * rand(1) - ...
    2 * NOISE_MAG * rand(1)));

task.col_pos = task.col_pos + col_step;
task.row_pos = task.row_pos + row_step;

if task.row_pos > task.row_max task.row_pos = task.row_max; end
if task.row_pos < task.row_min task.row_pos = task.row_min; end
if task.col_pos > task.col_max task.col_pos = task.col_max; end
if task.col_pos < task.col_min task.col_pos = task.col_min; end

% creates sensory input vector
task.fov = task.data( ...
    task.row_pos - floor( task.fov_hgt/2): ...
    task.row_pos + floor( task.fov_hgt/2), ...
    task.col_pos - floor( task.fov_wid/2): ...
    task.col_pos + floor( task.fov_wid/2) );

task.sensory_input = zeros(task.fov_span ^ 2, 1);

for row = 1:task.fov_span,
    for col = 1:task.fov_span,
        task.sensory_input(row + task.fov_span * (col - 1)) = ... 
        mean( mean( task.fov( (row - 1) * task.block_hgt + 1: ...
                                row * task.block_hgt, ...
                             (col - 1) * task.block_wid + 1: ...
                                col * task.block_wid )))...
                          / 256;
    end
end


task.sensory_input = task.sensory_input(:);
task.sensory_input = vertcat(task.sensory_input, 1 - task.sensory_input);
task.basic_feature_input = zeros(task.basic_feature_length,1);
task.reward = task_calc_reward( task);
